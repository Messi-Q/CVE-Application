# Sharing-variable-reentrancy

## Vendor
Smartcheck

## Vulnerability Type
Reentrancy

## Abstract
We found a vulnerability in smart contract of `Sharing-variable`, where an attacker can unexpectedly re-enter the contract by utilizing the sharing variable. 
This vulnerability cannot be checked by "Smartcheck", which is a smart contract audit tool. Therefore, it allows attackers to re-enter a contract and steal money.
(1) Given a contract `Victim` containing a transfer function `WithdrawReward` and a `GetFirstWithdrawBonus` function; 
(2) An attack contract `Malicious` calls the function `GetFirstWithdrawBonus` of contract `Victim`. Function `GetFirstWithdrawBonus` will then invoke the function `WithdrawReward` of contract `Victim` to transfer Ether to `Malicious`. 
(3) The transfer operation will automatically activate the `fallback` function of `Malicious`. In the `fallback` function, `Malicious` calls function `GetFirstWithdrawBonus`, which will modify the sharing variable and transfer money to `Malicious` again. 

## Details
"Smartcheck" is a Ethereum smart contract audit tool, which has a large group of users. You can use "Smartcheck" to check if a smart contract has vulnerabilities.

<div align=center><img width="520" height="240" src="./images/securify.png"/></div>
<div align=center>Figure 1: Smartcheck: smart contract aduit tool</div>

We found a typical example of sharing-variable reentrancy in the figure below.

<div align=center><img width="495" height="204" src="./images/state_unlocking.png"/></div>
<div align=center>Figure 2 A specific instance of sharing-variable reentrancy</div>

Contract `Vulnerable` contains a transfer function `WithdrawReward` and a `GetFirstWithdrawBonus` function.
* `GetFirstWithdrawBonus` is a function, which gives the bonus to a user who applies for the first time.
* `WithdrawReward` is a transfer function, which allows a recipient to withdraw his/her assets.
```
contract Victim {
  ...
  
  // Each recipient should only be able to claim the bonus once
  function WithdrawReward(address recipient) public {
      uint amountToWithdraw = rewardsForA[recipient];
      rewardsForA[recipient] = 0;
      if (recipient.call.value(amountToWithdraw)() == false) {
           throw;
      }
  }

  function GetFirstWithdrawBonus(address recipient) public {
      if (claimedBonus[recipient] == false) {  // Each recipient should only be able to claim the bonus once
           throw;
      }
      rewardsForA[recipient] += 100;
      WithdrawReward(recipient);  // At this point, the caller will be able to execute getFirstWithdrawalBonus again
      claimedBonus[recipient] = True;
  }
}
```

## Exploit
Contract `Malicious` contains an `attack` function and a `fallback` function.
* `attack` initates the attack to get the first-time bonus by calling the function `GetFirstWithdrawBonus`.
* `fallback` calls the function `GetFirstWithdrawBonus` to invoke the function `WithdrawReward` of contract `Victim`.
```
contract Malicious {
  ...
  
  function attack(){
    vul.GetFirstWithdrawBonus(_owner);
  }

  function () payable{ // fallback function
    count++;
    if(count < 10){
      vul.GetFirstWithdrawBonus(_owner);
    }
  }
}
```

**Analysis** `rewardsForA[recipient]` is the sharing variable as it records the amount of Ether that the caller has in the contract. 
`rewardsForA[recipient]` is set to zero before the transfer operation `if(recipient.call.value(amountToWithdraw)() == false)` (line 6 in Figure 1 left) of function `WithdrawReward` is executed. 
This transfer operation will trigger the `fallback` function of contract `Malicious`. However, `rewardsForA[recipient]` in function `GetFirstWithdrawBonus` is added to 100 (line 14 in Figure 1 left) before calling the function `WithdrawReward`, 
thus making the contract `Victm` believe that the attacker still has enough Ether in the contract. 
Then, the `fallback` function of contract `Malicious` calls the function `GetFirstWithdrawBonus` of `Victim`, leading to call the function `WithdrawReward` recurrently until the count reaches 10. `if(count < 10){vul.GetFirstWithdrawBonus(_owner);}` (line 11 in Figure 1 right).


## Conclusion
This reentrancy attack utilizes the sharing variable `rewardsForA[recipient]` to steal Ether from the `victim` contract. 
This is a trick of exploiting the control dependencies between functions, causing "Smartcheck" to miss the vulnerability detection. 
Even though `getFirstWithdrawalBonus` does not directly execute a transfer operation, the `withdrawReward` called by `getFirstWithdrawalBonus` is enough to make it vulnerable to reentrancy. 

## Reference
Official Website

https://tool.smartdec.net/

Github

https://github.com/smartdec/smartcheck

contract code

https://github.com/Messi-Q/SmartContracts/blob/master/Sharing-variable-reentrancy.sol



